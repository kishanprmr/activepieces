import { createAction, DynamicPropsValue, Property } from '@activepieces/pieces-framework';
import { MarkdownVariant } from '@activepieces/shared';
import { WorkbookRange } from '@microsoft/microsoft-graph-types';
import { excelAuth } from '../../index';
import {
	createMSGraphClient,
	getHeaders,
	getLastUsedRow,
	numberToColumnName,
} from '../common/helpers';
import { commonProps } from '../common/props';

export enum FilterOperator {
	TEXT_CONTAINS = 'TEXT_CONTAINS',
	TEXT_DOES_NOT_CONTAIN = 'TEXT_DOES_NOT_CONTAIN',
	TEXT_EXACTLY_MATCHES = 'TEXT_EXACTLY_MATCHES',
	TEXT_DOES_NOT_EXACTLY_MATCH = 'TEXT_DOES_NOT_EXACTLY_MATCH',
	TEXT_STARTS_WITH = 'TEXT_START_WITH',
	TEXT_DOES_NOT_START_WITH = 'TEXT_DOES_NOT_START_WITH',
	TEXT_ENDS_WITH = 'TEXT_ENDS_WITH',
	TEXT_DOES_NOT_END_WITH = 'TEXT_DOES_NOT_END_WITH',
	TEXT_MATCHES_ANY_OF = 'TEXT_MATCHES_ANY_OF',
	TEXT_MATCHES_NONE_OF = 'TEXT_MATCHES_NONE_OF',
	NUMBER_IS_GREATER_THAN = 'NUMBER_IS_GREATER_THAN',
	NUMBER_IS_LESS_THAN = 'NUMBER_IS_LESS_THAN',
	NUMBER_IS_EQUAL_TO = 'NUMBER_IS_EQUAL_TO',
	BOOLEAN_IS_TRUE = 'BOOLEAN_IS_TRUE',
	BOOLEAN_IS_FALSE = 'BOOLEAN_IS_FALSE',
	DATE_IS_BEFORE = 'DATE_IS_BEFORE',
	DATE_IS_EQUAL = 'DATE_IS_EQUAL',
	DATE_IS_AFTER = 'DATE_IS_AFTER',
	LIST_CONTAINS = 'LIST_CONTAINS',
	LIST_DOES_NOT_CONTAIN = 'LIST_DOES_NOT_CONTAIN',
	LIST_IS_EMPTY = 'LIST_IS_EMPTY',
	LIST_IS_NOT_EMPTY = 'LIST_IS_NOT_EMPTY',
	EXISTS = 'EXISTS',
	DOES_NOT_EXIST = 'DOES_NOT_EXIST',
}

export const appendMultipleRowsAction = createAction({
	auth: excelAuth,
	name: 'append_multiple_rows',
	description: 'Appends multiple row of values to a worksheet.',
	displayName: 'Append Multiple Rows',
	props: {
		storageSource: commonProps.storageSource,
		siteId: commonProps.siteId,
		documentId: commonProps.documentId,
		workbookId: commonProps.workbookId,
		worksheetId: commonProps.worksheetId,
		values: commonProps.worksheetValues(true),
		// values: Property.DynamicProperties({
		// 	auth: excelAuth,
		// 	displayName: 'Values',
		// 	required: true,
		// 	refreshers: ['workbook_id', 'worksheet_id'],
		// 	props: async ({ auth, workbook_id, worksheet_id }) => {
		// 		if (
		// 			!auth ||
		// 			(workbook_id ?? '').toString().length === 0 ||
		// 			(worksheet_id ?? '').toString().length === 0
		// 		) {
		// 			return {};
		// 		}

		// 		const authProp: OAuth2PropertyValue = auth as OAuth2PropertyValue;

		// 		const firstRow = await excelCommon.getHeaders(
		// 			workbook_id as unknown as string,
		// 			authProp['access_token'],
		// 			worksheet_id as unknown as string
		// 		);

		// 		const fields: DynamicPropsValue = {};

		// 		const columns: {
		// 			[key: string]: any;
		// 		} = {};
		// 		for (const key in firstRow) {
		// 			columns[key] = Property.ShortText({
		// 				displayName: firstRow[key].toString(),
		// 				description: firstRow[key].toString(),
		// 				required: false,
		// 				defaultValue: '',
		// 			});
		// 		}

		// 		fields['values'] = Property.Array({
		// 			displayName: 'Values',
		// 			required: true,
		// 			properties: columns,
		// 		});

		// 		return fields;
		// 	},
		// }),
		filterMarkdown: Property.MarkDown({
			variant: MarkdownVariant.INFO,
			value: `Use below Filter properties to insert only the rows that meet your conditions.`,
		}),
		filterColumn: commonProps.filterColumn,
		filterType: Property.StaticDropdown({
			displayName: 'Filter Type',
			required: false,
			options: {
				disabled: false,
				options: [
					{
						label: '(Text) Exactly matches',
						value: FilterOperator.TEXT_EXACTLY_MATCHES,
					},
					{
						label: '(Text) Does not exactly match',
						value: FilterOperator.TEXT_DOES_NOT_EXACTLY_MATCH,
					},
					{
						label: '(Text) Matches any of',
						value: FilterOperator.TEXT_MATCHES_ANY_OF,
					},
					{
						label: '(Text) Matches none of',
						value: FilterOperator.TEXT_MATCHES_NONE_OF,
					},
				],
			},
		}),
		filterValue: Property.DynamicProperties({
			displayName: 'Filter Value',
			refreshers: ['filterType'],
			auth: excelAuth,
			required: false,
			props: async ({ filterType }) => {
				if (!filterType) return {};

				const filterCondition = filterType as unknown as FilterOperator;

				const props: DynamicPropsValue = {};

				switch (filterCondition) {
					case FilterOperator.TEXT_EXACTLY_MATCHES:
					case FilterOperator.TEXT_DOES_NOT_EXACTLY_MATCH:
						props['value'] = Property.ShortText({
							displayName: 'Filter Value',
							required: false,
						});
						break;
					case FilterOperator.TEXT_MATCHES_ANY_OF:
					case FilterOperator.TEXT_MATCHES_NONE_OF:
						props['value'] = Property.Array({
							displayName: 'Filter Value',
							required: false,
						});
						break;
					default:
						break;
				}

				return props;
			},
		}),
	},
	async run({ propsValue, auth }) {
		const {
			workbookId,
			worksheetId,
			storageSource,
			siteId,
			documentId,
			filterColumn,
			filterType: filterCondition,
		} = propsValue;
		const rawFilterValue = propsValue.filterValue?.['value'];
		const inputValues: Array<Record<string, any>> = propsValue.values['values'] ?? [];

		if (storageSource === 'sharepoint' && (!siteId || !documentId)) {
			throw new Error('please select SharePoint site and document library.');
		}

		const drivePath =
			storageSource === 'onedrive' ? '/me/drive' : `/sites/${siteId}/drives/${documentId}`;

		const firstRow = await getHeaders(
			auth.access_token,
			drivePath,
			workbookId as unknown as string,
			worksheetId as unknown as string
		);

		const columnCount = firstRow.length;

		let filteredRowValues = inputValues;

		if (filterColumn) {
			if (!filterCondition || !rawFilterValue) {
				throw new Error(
					'When a filter column is selected, filter condition and value are required.'
				);
			}

			const filterValues: string[] = Array.isArray(rawFilterValue)
				? rawFilterValue.map((v) => String(v).trim().toLowerCase())
				: rawFilterValue != null
				? [String(rawFilterValue).trim()]
				: [];

			filteredRowValues = inputValues.filter((row) => {
				if (!filterColumn) return true;

				const value = String(row[filterColumn] ?? '').trim();

				switch (filterCondition) {
					case FilterOperator.TEXT_EXACTLY_MATCHES:
						return value === filterValues[0];

					case FilterOperator.TEXT_DOES_NOT_EXACTLY_MATCH:
						return value !== filterValues[0];

					case FilterOperator.TEXT_MATCHES_ANY_OF:
						return filterValues.includes(value.toLowerCase());

					case FilterOperator.TEXT_MATCHES_NONE_OF:
						return !filterValues.includes(value.toLowerCase());

					default:
						return true;
				}
			});
		}

		const formattedValues = filteredRowValues.map((v) =>
			Array.from({ length: columnCount }, (_, i) => v[i] ?? null)
		);

		if (formattedValues.length === 0) {
			throw new Error(
				'No rows to insert. The provided/filtered rows did not contain any values.'
			);
		}

		const lastUsedRow = await getLastUsedRow(
			auth.access_token,
			drivePath,
			workbookId,
			worksheetId
		);

		const lastUsedColumn = numberToColumnName(columnCount);

		const rangeFrom = `A${lastUsedRow + 1}`;
		const rangeTo = `${lastUsedColumn}${lastUsedRow + formattedValues.length}`;

		const client = createMSGraphClient(auth.access_token);

		const url = `${drivePath}/items/${workbookId}/workbook/worksheets/${worksheetId}/range(address='${rangeFrom}:${rangeTo}')`;

		const requestBody = {
			values: formattedValues,
		};

		const res: WorkbookRange = await client.api(url).update(requestBody);

		const {
			numberFormat,
			formulas,
			formulasLocal,
			formulasR1C1,
			valueTypes,
			values,
			text,
			...rest
		} = res;

		return rest;
	},
});
